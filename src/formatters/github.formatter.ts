import { GitHubService } from "../services";
import { ReviewReport } from "../types";

export class GitHubFormatter {
  constructor(private githubService: GitHubService) {}

  async format(report: ReviewReport): Promise<void> {
    const [owner, repo] = report.repository.split("/");

    const summaryComment = this.buildSummaryComment(report);
    await this.githubService.postReviewSummary(
      owner,
      repo,
      report.prNumber,
      summaryComment,
    );

    const criticalComments = report.critical
      .filter((comment) => comment.line)
      .map((comment) => ({
        body: `ðŸš¨ **CRITICAL** ${comment.body}`,
        path: comment.file,
        line: comment.line,
      }));

    const warningComments = report.warnings
      .filter((comment) => comment.line)
      .map((comment) => ({
        body: `âš ï¸ **WARNING** ${comment.body}`,
        path: comment.file,
        line: comment.line,
      }));

    const allComments = [...criticalComments, ...warningComments];

    if (allComments.length > 0) {
      await this.githubService.postReviewComments(
        owner,
        repo,
        report.prNumber,
        allComments,
      );
    }

    console.log("Review comments posted to GitHub PR");
  }

  private buildSummaryComment(report: ReviewReport): string {
    let comment = `## ðŸ¤– AI Code Review\n\n`;
    comment += `**Overall Score:** ${report.overallScore}/10\n\n`;

    comment += `### ðŸ“‹ Summary\n${report.summary}\n\n`;

    // Critical Issues
    comment += `### ðŸš¨ Critical Issues\n`;
    if (report.critical.length > 0) {
      comment += `> **Must be fixed before merge**\n\n`;
      report.critical.forEach((issue, index) => {
        comment += `${index + 1}. **\`${issue.file}${issue.line ? `:${issue.line}` : ""}\`** - ${issue.body}\n`;
      });
      comment += `\n`;
    } else {
      comment += `âœ… No critical issues found\n\n`;
    }

    // Warnings
    comment += `### âš ï¸ Warnings\n`;
    if (report.warnings.length > 0) {
      comment += `> **Should be addressed**\n\n`;
      report.warnings.forEach((warning, index) => {
        comment += `${index + 1}. **\`${warning.file}${warning.line ? `:${warning.line}` : ""}\`** - ${warning.body}\n`;
      });
      comment += `\n`;
    } else {
      comment += `âœ… No warnings found\n\n`;
    }

    // Good Practices
    comment += `### âœ… Good Practices\n`;
    if (report.good.length > 0) {
      report.good.forEach((item) => {
        comment += `- ${item}\n`;
      });
      comment += `\n`;
    } else {
      comment += `No specific highlights\n\n`;
    }

    comment += `---\n*Generated by AI PR Reviewer*`;

    return comment;
  }
}
